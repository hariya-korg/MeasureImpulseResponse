<!DOCTYPE HTML>
<html>

<head>
    <meta charset='utf-8'></meta>
    <title>Measure Impulse Response</title>
    <link type='text/css' rel='stylesheet' href='style.css'></link>
    <script type="text/javascript" src="fft.js"></script>
    <script type='text/javascript'>
        (function(){
            var status,measure,calib;
            var console_obj = window.console;
            var N=65536*2;//信号長
            var n=1;//0~1
            var J = Math.round(N/4*n)*2 ;//実効長
            var a =J*Math.PI/(N/2)/Math.log(N/2);//計算式
            var latency  = 4096;
            var audioCtx = new(window.AudioContext || window.webkitAudioContext)();
            var sampleRate;
            var ir;
            var scriptNode;

            function onDOMContentLoaded() {

                status = document.getElementById('status');
                measure = document.getElementById('measure');
                calib = document.getElementById('calib');

                status.innerHTML = 'Initialized';
                measure.innerHTML = 'Start';
                measure.value = false;
                measure.addEventListener('click', function(event) {
                    var value = this.value == 'false';
                    if (value) {
                        onStartMeasure();
                    } else {
                        onStopMeasure();
                    }
                    this.value = value;
                }, false);

                calib.innerHTML = 'calib';
                calib.value = false;
                calib.addEventListener('click', function(event) {
                    var value2 = this.value == 'false';
                    if (value2) {
                        onStartCalib();
                    } else {
                        onStopCalib();
                    }
                    this.value = value2;
                }, false);

                document.getElementById('playir').addEventListener('click',function(event){
                    soundplay(ir);
                },false);
            }

            var oscillator;
            function onStartCalib(){
                calib.innerHTML =  'StopSine'
                oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.value = 1000;
                oscillator.connect(audioCtx.destination);
                oscillator.start();
                navigator.getUserMedia = ( navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia ||
                navigator.msGetUserMedia);

                navigator.getUserMedia ({ audio:true }, function(stream) {
                    var source = audioCtx.createMediaStreamSource(stream);
                    var inputmax=0;
                    var inputmin=0;
                    scriptNode = audioCtx.createScriptProcessor(latency);
                    scriptNode.onaudioprocess = function(audioProcessingEvent) {
                        // The input buffer is the song we loaded earlier
                        var inputBuffer = audioProcessingEvent.inputBuffer;
                        for (var channel = 0; channel < inputBuffer.numberOfChannels; channel++) {
                            var inputData = inputBuffer.getChannelData(channel);
                                var max = Math.max.apply(null,inputData);
                                var min = Math.abs(Math.min.apply(null,inputData));
                                if (max<min){
                                    max = min ;
                                }
                            }
                        if(20*Math.log10(max)>-12){
                            status.innerHTML='too large';
                            status.style.color = "red";
                        }else if(20*Math.log10(max)<-24){
                            status.innerHTML='too small';
                            status.style.color = "black";
                        }
                        else{
                            status.innerHTML = 'proper';
                            status.style.color = "green";
                        }
                    }
                    source.connect(scriptNode);
                    scriptNode.connect(audioCtx.destination);
                },function(err){ alert("miss") });
            }

            function onStopCalib(){
                status.innerHTML = 'Initialized';
                calib.innerHTML =  'calib'
                oscillator.stop();
                scriptNode.disconnect();
            }


            function onStartMeasure() {
                status.innerHTML = 'Measuring...';
                measure.innerHTML = 'Stop';
                try{
                    var recordData = new Float32Array(N);
                    var repeat = eval(form1.textBox1.value);//同期加算回数
                    sampleRate = audioCtx.sampleRate;
                    navigator.getUserMedia = ( navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia);

                    navigator.getUserMedia ({ audio:true }, function(stream) {
                        var pinktsp = createPinktsp(N);
                        var shift = pinktsp.shift;
                        var source = audioCtx.createMediaStreamSource(stream);
                        scriptNode = audioCtx.createScriptProcessor(latency);
                        var s=0;
                        var l=0;
                        //  pinktsp[0]=1;
                        //  shift=0;
                        scriptNode.onaudioprocess = function(audioProcessingEvent) {
                            var inputBuffer = audioProcessingEvent.inputBuffer;
                            var outputBuffer = audioProcessingEvent.outputBuffer;
                            // Loop through the output channels (in this case there is only one)
                            for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
                                var inputData = inputBuffer.getChannelData(channel);
                                var outputData = outputBuffer.getChannelData(channel);
                                for (var sample = 0; sample < outputBuffer.length; sample++) {
                                    // make output equal to the same as the input
                                    if(s< N/latency){
                                        outputData[sample] = pinktsp[sample+latency*s];
                                    }else{
                                        outputData[sample] = 0;
                                    }
                                }
                            }
                            var lag = 13300;
                            for (var i = 0; i < latency; i++){
                                for (m=1; m<repeat;m++){
                                    if (N*m<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*(m+1)-shift){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift;
                                            recordData[p] += inputData[i];
                                    } else if(N*m-shift<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*m){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift+N;
                                        recordData[p] += inputData[i];
                                    }
                                }
                            }
                            if (sample == latency && s< N/latency-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency-1 && l<repeat-1){
                                s=0;
                                l=l+1;
                                drawGraph(recordData);

                            }else if (sample == latency && s< N/latency+5 && l==repeat-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency+5 && l==repeat-1){
                                this.disconnect();
                                normalize(recordData);
                                drawGraph(recordData);
                                console.log(recordData);
                                 ir = onFinishMeasure(recordData);
                            }

                        }
                        source.connect(scriptNode);
                        scriptNode.connect(audioCtx.destination);
                    }, function(err){ alert("miss") });
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function onStopMeasure() {
                status.innerHTML = 'Interrupted';
                measure.innerHTML = 'Start';
                scriptNode.disconnect();
            }

            function onFinishMeasure(recordData) {//逆Filter,encodeWAV,exportWAV
                var ir = getImpulseResponse(recordData);
                var d = document.querySelectorAll('.download')[0];//downloadWAV
                var wavurl = exportWAV(ir);
                d.download = 'ir.wav';
                d.href = wavurl;
                d.classList.remove('disabled');
                status.innerHTML = 'Finished';
                measure.innerHTML = 'Start';
                measure.value = false;
                drawGraph(ir);
                return ir;
            }

            function exportWAV(audioData){
                try{
                    var buffer = new ArrayBuffer(44 + audioData.length * 2);//encodeWAV start
                    var view = new DataView(buffer);
                    var writeString = function(view, offset, string) {
                        for (var i = 0; i < string.length; i++){
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };
                    var floatTo16BitPCM = function(output, offset, input) {
                        for (var i = 0; i < input.length; i++, offset += 2){
                            var s = Math.max(-1, Math.min(1, input[i]));
                            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                        }
                    };
                    writeString(view, 0, 'RIFF');  // RIFFヘッダ
                    view.setUint32(4, 32 + audioData.length * 2, true); // これ以降のファイルサイズ
                    writeString(view, 8, 'WAVE'); // WAVEヘッダ
                    writeString(view, 12, 'fmt '); // fmtチャンク
                    view.setUint32(16, 16, true); // fmtチャンクのバイト数
                    view.setUint16(20, 1, true); // フォーマットID
                    view.setUint16(22, 1, true); // チャンネル数
                    view.setUint32(24, sampleRate, true); // サンプリングレート
                    view.setUint32(28, sampleRate * 2, true); // データ速度
                    view.setUint16(32, 2, true); // ブロックサイズ
                    view.setUint16(34, 16, true); // サンプルあたりのビット数
                    writeString(view, 36, 'data'); // dataチャンク
                    view.setUint32(40, audioData.length * 2, true); // 波形データのバイト数
                    floatTo16BitPCM(view, 44, audioData); // 波形データ    //encodeWAV end

                    var audioBlob = new Blob([view], { type: 'audio/wav' });
                    var myURL = window.URL || window.webkitURL;
                    var url = myURL.createObjectURL(audioBlob);

                    return url;
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function createPinktsp(N){
                var freqr = new Float32Array(N);
                var freqi = new Float32Array(N);


                for (var k=1 ; k<=N/2 ; k++){
                    freqr[k] = Math.sqrt(1/k)*Math.cos(-a*k*Math.log(k));
                    freqi[k] = Math.sqrt(1/k)*Math.sin(-a*k*Math.log(k));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    freqr[k] = freqr[N-k];
                    freqi[k] = -freqi[N-k];
                }
                freqr[0] = 1.0;
                freqi[0] = 0;

                var fftn = new FFTNayukis(N);
                fftn.ifft(freqr,freqi);

                var shift =Math.round(N/2-J/2*(1+(1/Math.log(N/2))));
                var D=1;
                for (var q=1 ; q<10000 ; q++){
                    if (D === 0) { break; }

                    for (var n=0 ; n<shift ; n++){
                        freqi[n]=freqr[n-shift+N];//freqiにfreqrをシフトしたものを入れる
                    }
                    for (var m=shift ; m<N ; m++){
                        freqi[m]=freqr[m-shift];
                    }

                    var sample = 50;
                    var D=sample-1;
                    for (var l=1 ; l<sample ; l++){
                         if(freqi[N-sample+l]<freqi[N-sample+l-1])
                         D = sample-l-1;
                    }
                    shift=shift+D;
                }
                normalize(freqi);
                // drawGraph(freqi);
                freqi.shift = shift;
                return freqi;
            }

            function getImpulseResponse(recordData){
                var freqi = new Float32Array(N);
                var ifreqr = new Float32Array(N);
                var ifreqi = new Float32Array(N);
                var fftn = new FFTNayukis(N);
                fftn.fft(recordData,freqi);
                for (var k=0; k<=N/2; k++) {
                 ifreqr[k] = Math.sqrt(k)*(recordData[k]*Math.cos(a*k*Math.log(k))-freqi[k]*Math.sin(a*k*Math.log(k)));
                 ifreqi[k] = Math.sqrt(k)*(recordData[k]*Math.sin(a*k*Math.log(k))+freqi[k]*Math.cos(a*k*Math.log(k)));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    ifreqr[k] = ifreqr[N-k];
                    ifreqi[k] = -ifreqi[N-k];
                }
                 ifreqr[0]=1.0;
                 ifreqi[0]=0;
                fftn.ifft(ifreqr,ifreqi);
                normalize(ifreqr);
                return ifreqr;
            }

            function normalize(array){
                var max = Math.max.apply(null,array);
                var min = Math.abs(Math.min.apply(null,array));
                if (max<min)
                    max = min ;
                for (var l=0 ; l<array.length ; l++){
                    array[l]=array[l]/max;
                }
            }

            function drawGraph(array) {
                var width = window.innerWidth * 0.8;
                var height = window.innerHeight * 0.8;
                var center = height * 0.4;
                var canvas = document.getElementById('graph');
                canvas.setAttribute('width', width);
                canvas.setAttribute('height', height);
                var length = array.length;
                var unit = width / (length - 1.0);
                var canvasCtx = canvas.getContext('2d');
                canvasCtx.clearRect(0.0, 0.0, width, height);
                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center * (1.0 - array[(length - 1)|0]));
                for (var index = (length - 2)|0; index >=0; index = (index - 1)|0) {
                    canvasCtx.lineTo(unit * index, center * (1.0 - array[index<<1>>1]));
                }
                canvasCtx.stroke();
                canvasCtx.strokeStyle = 'rgb(0, 0, 255)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center);
                canvasCtx.lineTo(0, center);
                canvasCtx.stroke();
            }

            function soundplay(array){
                var channels = 1;
                var myArrayBuffer = audioCtx.createBuffer(channels, N, audioCtx.sampleRate);
                for (var channel = 0; channel < channels; channel++) {
                    // 実際のデータの配列を得る
                    var nowBuffering = myArrayBuffer.getChannelData(channel);
                    for (var i = 0; i < N; i++) {
                        // Math.random()は[0; 1.0]である
                        // 音声は[-1.0; 1.0]である必要がある
                        nowBuffering[i] = array[i];
                        // nowBuffering[i] = Math.random() * 2 - 1;
                    }
                }                // AudioBufferSourceNodeを得る
                // これはAudioBufferを再生するときに使うAudioNodeである
                var source = audioCtx.createBufferSource();
                // AudioBufferSourceNodeにバッファを設定する
                source.buffer = myArrayBuffer;
                // AudioBufferSourceNodeを出力先に接続すると音声が聞こえるようになる
                source.connect(audioCtx.destination);
                // 音源の再生を始める
                source.start();
            };

            window.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);
        })();

    </script>
</head>

<body>
    <button id='measure'></button>
    <button id='calib'></button>
    <button id='playir'>playir</button>
    <form name="form1" id="id_form1" action="">
    number of recording times: <input size ="1" name="textBox1" id="id_textBox1" type="text" value="3" />
    </form>
    <p id='status'></p>
    <p><a href="#" class="download disabled">Download IR WAV file</a></p>
    <canvas id='graph'></canvas>
</body>

</html>
