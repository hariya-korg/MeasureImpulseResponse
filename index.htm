<!DOCTYPE HTML>
<html>

<head>
    <meta charset='utf-8'></meta>
    <title>Measure Impulse Response</title>
    <link type='text/css' rel='stylesheet' href='style.css'></link>
    <script type="text/javascript" src="fft.js"></script>
    <script src="jquery-2.0.3.min.js"></script>
    <script src="jquery.xdomainajax.js"></script>
    <script type='text/javascript'>


        (function(){//wavのステレオ化、グラフの色指定、ダウンロードボタンの無効化、
            var status,measure,calib;
            var N,n,j,a;
            var latency  = 4096;
            var sampleRate;
            var ir;
            var scriptNode;
            var audioCtx = new(window.AudioContext || window.webkitAudioContext)();

            var revlevel = audioCtx.createGain();
            revlevel.gain.value = 0.5;
            revlevel.connect(audioCtx.destination);

            var convolver = audioCtx.createConvolver();
            convolver.connect(revlevel);

            function createAudioBuffer(array) {
                var channels = 2;
                var length = array.length;
                var buffer = audioCtx.createBuffer(channels, length, audioCtx.sampleRate);
                for (var channel = (channels - 1)|0; (channel|0) >= (0|0); channel = (channel - 1)|0) {
                    var data = buffer.getChannelData(channel);
                    for (var index = (length - 1)|0; (index|0) >= (0|0); index = (index - 1)|0) {
                        data[index<<1>>1] = array[index<<1>>1];
                    }
                }
                return buffer;
            }

            function loadAudioFile(url, onload, audio_ctx) {
                /* load buffer asynchronously */
                var request = new XMLHttpRequest();
                request.open('GET', url, true);
                request.responseType = 'arraybuffer';

                request.onload = function() {
                    /* decode audio data asynchronously in request.response */
                    audio_ctx.decodeAudioData(
                        request.response,
                        function(buffer) {
                            if (!buffer) {
                                alert('error in decoding audio data : ' + url);
                                return;
                            }
                            onload(buffer);
                        },
                        function(error) {
                            console.error('error in decodeAudioData (loadAudioFile)', error);
                        }
                    );
                }

                request.onerror = function(error) {
                    alert('error in loadAudioFile', error);
                }

                request.send();
            }

            function onDOMContentLoaded() {
                status = document.getElementById('status');
                measure = document.getElementById('measure');
                calib = document.getElementById('calib');

                status.innerHTML = 'Initialized';
                measure.innerHTML = 'Start';
                measure.value = false;
                measure.addEventListener('click', function(event) {
                    var value = this.value == 'false';
                    if (value) {
                        onStartMeasure();
                    } else {
                        onStopMeasure();
                    }
                    this.value = value;
                }, false);

                calib.innerHTML = 'Calib';
                calib.value = false;
                calib.addEventListener('click', function(event) {
                    var value2 = this.value == 'false';
                    if (value2) {
                        onStartCalib();
                    } else {
                        onStopCalib();
                    }
                    this.value = value2;
                }, false);

                document.getElementById('downloadir').addEventListener('click',function(event){
                    var a = document.createElement('a');
                    a.href = createWavURL(ir);
                    a.download = 'ir.wav';
                    a.click();
                },false);

                document.getElementById('playir').addEventListener('click',function(event){
                    var source = audioCtx.createBufferSource();
                    source.buffer = createAudioBuffer(ir);
                    source.connect(audioCtx.destination);
                    source.start();
                },false);

                document.getElementById('playconv').addEventListener('click',function(event){
                    var source = audioCtx.createBufferSource();
                    source.connect(convolver);
                    loadAudioFile(document.getElementById('select').value, function(buffer){
                        source.buffer = buffer;
                        source.start();
                    }, audioCtx);
                },false);

                document.getElementById('revlevel').addEventListener('change',function(event){
                    var level = parseInt(this.value);
                    revlevel.gain.value = level * 0.01;
                    document.getElementById('revdisp').innerHTML = level;
                },false);

                document.getElementById('reverb').style.display = 'none';
            }

            var oscillator;
            function onStartCalib(){
                calib.innerHTML =  'StopSine'
                oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.value =eval(form_calib.calibfreq.value);
                oscillator.connect(audioCtx.destination);
                oscillator.start();
                navigator.getUserMedia = ( navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia ||
                navigator.msGetUserMedia);
                navigator.getUserMedia ({audio: {
                    "mandatory": {
                        "googEchoCancellation": false,
                        "googAutoGainControl": false,
                        "googNoiseSuppression": false,
                        "googHighpassFilter": false
                    },
                    "optional": []
                }}, function(stream) {
                    var source = audioCtx.createMediaStreamSource(stream);
                    var inputmax=0;
                    var inputmin=0;
                    scriptNode = audioCtx.createScriptProcessor(latency);
                    scriptNode.onaudioprocess = function(audioProcessingEvent) {
                        // The input buffer is the song we loaded earlier
                        var inputBuffer = audioProcessingEvent.inputBuffer;
                        for (var channel = 0; channel < inputBuffer.numberOfChannels; channel++) {
                            var inputData = inputBuffer.getChannelData(channel);
                            var inputmax = Math.max.apply(null,inputData);
                            var inputmin = Math.abs(Math.min.apply(null,inputData));
                            if (inputmax<inputmin){
                                    inputmax = inputmin ;
                            }
                        }
                        var maxdb = 20*Math.log10(inputmax);
                        if(maxdb > -6){
                            status.innerHTML='too large '+ Math.floor(maxdb) +'dB';
                            status.style.color = "red";
                        }else if(maxdb < -20){
                            status.innerHTML='too small '+ Math.floor(maxdb) +'dB';
                            status.style.color = "black";
                        }
                        else{
                            status.innerHTML = 'proper '+ Math.floor(maxdb) +'dB';
                            status.style.color = "green";
                        }
                    }
                    source.connect(scriptNode);
                    scriptNode.connect(audioCtx.destination);
                },function(err){ alert("miss") });
            }

            function onStopCalib(){
                status.innerHTML = 'Initialized';
                status.style.color = "black";
                calib.innerHTML =  'Calib'
                oscillator.stop();
                scriptNode.disconnect();
            }

            function onStartMeasure() {
                status.innerHTML = 'Measuring...';
                measure.innerHTML = 'Stop';
                document.getElementById('reverb').style.display = 'none';

                N= Math.round(65536*4/3*eval(form_recordlength.recordlength.value));
                for (var b=1; b<20; b++){
                    if (Math.pow(2,b)<N && N<=Math.pow(2,b+1)){
                        N = Math.pow(2,b+1);
                    }
                }
                n=1;//0~1
                J = Math.round(N/4*n)*2;//実効長
                a = J*Math.PI/(N/2)/Math.log(N/2);//計算式
                try{
                    var recordData = new Float32Array(N);
                    var repeat = eval(form_recordtimes.recordtimes.value);//同期加算回数
                    sampleRate = audioCtx.sampleRate;
                    navigator.getUserMedia = ( navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia);

                    navigator.getUserMedia ({audio: {
                        "mandatory": {
                            "googEchoCancellation": false,
                            "googAutoGainControl": false,
                            "googNoiseSuppression": false,
                            "googHighpassFilter": false
                        },
                        "optional": []
                    }}, function(stream) {
                        var pinktsp = createPinktsp(N);
                        pinktsp[0]=0;
                        pinktsp[N-1]=0;
                        var shift = pinktsp.shift;
                        var source = audioCtx.createMediaStreamSource(stream);
                        scriptNode = audioCtx.createScriptProcessor(latency);
                        var s=0;
                        var l=0;

                        scriptNode.onaudioprocess = function(audioProcessingEvent) {
                            var inputBuffer = audioProcessingEvent.inputBuffer;
                            var outputBuffer = audioProcessingEvent.outputBuffer;
                            // Loop through the output channels (in this case there is only one)
                            for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
                                var inputData = inputBuffer.getChannelData(channel);
                                var outputData = outputBuffer.getChannelData(channel);
                                for (var sample = 0; sample < outputBuffer.length; sample++) {
                                    // make output equal to the same as the input
                                    if(s< N/latency){
                                        outputData[sample] = pinktsp[sample+latency*s];
                                    }else{
                                        outputData[sample] = 0;
                                    }
                                }
                            }
                            var lag = 13300+eval(form_plusshift.plusshift.value);

                            for (var i = 0; i < latency; i++){
                                for (m=1; m<repeat;m++){
                                    if (N*m<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*(m+1)-shift){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift;
                                            recordData[p] += inputData[i];
                                    } else if(N*m-shift<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*m){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift+N;
                                        recordData[p] += inputData[i];
                                    }
                                }
                            }
                            if (sample == latency && s< N/latency-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency-1 && l<repeat-1){
                                s=0;
                                l=l+1;
                                drawGraph(recordData);

                            }else if (sample == latency && s< N/latency+5 && l==repeat-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency+5 && l==repeat-1){
                                this.disconnect();
                                normalize(recordData);
                                drawGraph(recordData);
                                ir = onFinishMeasure(recordData);
                                convolver.buffer = createAudioBuffer(ir);
                            }
                        }
                        source.connect(scriptNode);
                        scriptNode.connect(audioCtx.destination);
                    }, function(err){ alert("miss") });
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function onStopMeasure() {
                status.innerHTML = 'Interrupted';
                measure.innerHTML = 'Start';
                scriptNode.disconnect();
            }

            function onFinishMeasure(recordData) {//逆Filter,encodeWAV,exportWAV
                var ir = getImpulseResponse(recordData);
                var ir2 = new Float32Array(N/2);
                for (m=0; m< ir.length/2; m++){
                    ir2[m] = ir[m];
                }

                status.innerHTML = 'Finished';
                measure.innerHTML = 'Start';
                measure.value = false;
                drawGraph(ir);

                document.getElementById('reverb').style.display = 'block';
                return ir2;
            }

            function createWavURL(audioData){
                try{
                    var stereo = new Float32Array(audioData.length*2);
                    for (s=0; s<audioData.length;s++){
                        stereo[2*s] = audioData[s];
                        stereo[2*s+1] = audioData[s];
                    }
                    var buffer = new ArrayBuffer(44 + stereo.length * 2);//encodeWAV start
                    var view = new DataView(buffer);
                    var writeString = function(view, offset, string) {
                        for (var i = 0; i < string.length; i++){
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };
                    var floatTo16BitPCM = function(output, offset, input) {
                        for (var i = 0; i < input.length; i++, offset += 2){
                            var s = Math.max(-1, Math.min(1, input[i]));
                            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                        }
                    };
                    writeString(view, 0, 'RIFF');  // RIFFヘッダ
                    view.setUint32(4, 32 + stereo.length * 2, true); // これ以降のファイルサイズ
                    writeString(view, 8, 'WAVE'); // WAVEヘッダ
                    writeString(view, 12, 'fmt '); // fmtチャンク
                    view.setUint32(16, 16, true); // fmtチャンクのバイト数
                    view.setUint16(20, 1, true); // フォーマットID
                    view.setUint16(22, 2, true); // チャンネル数
                    view.setUint32(24, sampleRate, true); // サンプリングレート
                    view.setUint32(28, sampleRate * 2*2, true); // データ速度
                    view.setUint16(32, 2*2, true); // ブロックサイズ
                    view.setUint16(34, 16, true); // サンプルあたりのビット数
                    writeString(view, 36, 'data'); // dataチャンク
                    view.setUint32(40, stereo.length * 2, true); // 波形データのバイト数
                    floatTo16BitPCM(view, 44, stereo); // 波形データ    //encodeWAV end

                    var audioBlob = new Blob([view], { type: 'audio/wav' });
                    var myURL = window.URL || window.webkitURL;
                    var url = myURL.createObjectURL(audioBlob);

                    return url;
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function createPinktsp(N){
                var freqr = new Float32Array(N);
                var freqi = new Float32Array(N);

                for (var k=1 ; k<=N/2 ; k++){
                    freqr[k] = Math.sqrt(1/k)*Math.cos(-a*k*Math.log(k));
                    freqi[k] = Math.sqrt(1/k)*Math.sin(-a*k*Math.log(k));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    freqr[k] = freqr[N-k];
                    freqi[k] = -freqi[N-k];
                }
                freqr[0] = 1.0;
                freqi[0] = 0;

                var fftn = new FFTNayukis(N);
                fftn.ifft(freqr,freqi);

                var shift =Math.round(N/2-J/2*(1+(1/Math.log(N/2))));
                var D=1;
                for (var q=1 ; q<10000 ; q++){
                    if (D === 0) { break; }

                    for (var n=0 ; n<shift ; n++){
                        freqi[n]=freqr[n-shift+N];//freqiにfreqrをシフトしたものを入れる
                    }
                    for (var m=shift ; m<N ; m++){
                        freqi[m]=freqr[m-shift];
                    }

                    var sample = 50;
                    var D=sample-1;
                    for (var l=1 ; l<sample ; l++){
                         if(freqi[N-sample+l]<freqi[N-sample+l-1])
                         D = sample-l-1;
                    }
                    shift=shift+D;
                }
                normalize(freqi);
                freqi.shift = shift;
                return freqi;
            }

            function getImpulseResponse(recordData){
                var freqi = new Float32Array(N);
                var ifreqr = new Float32Array(N);
                var ifreqi = new Float32Array(N);
                var fftn = new FFTNayukis(N);
                fftn.fft(recordData,freqi);
                for (var k=0; k<=N/2; k++) {
                 ifreqr[k] = Math.sqrt(k)*(recordData[k]*Math.cos(a*k*Math.log(k))-freqi[k]*Math.sin(a*k*Math.log(k)));
                 ifreqi[k] = Math.sqrt(k)*(recordData[k]*Math.sin(a*k*Math.log(k))+freqi[k]*Math.cos(a*k*Math.log(k)));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    ifreqr[k] = ifreqr[N-k];
                    ifreqi[k] = -ifreqi[N-k];
                }
                 ifreqr[0]=1.0;
                 ifreqi[0]=0;
                fftn.ifft(ifreqr,ifreqi);
                normalize(ifreqr);
                return ifreqr;
            }

            function normalize(array){
                var copy = array.slice(0);
                copy.sort();
                var max = copy[copy.length-1];
                var min = Math.abs(copy[0]);
                 if (max<min)
                    max = min ;
                for (var l=0 ; l<array.length ; l++){
                    array[l]=array[l]/max;
                }
            }

            function drawGraph(array) {
                var width = window.innerWidth * 0.8;
                var height = window.innerHeight * 0.8;
                var center = height * 0.4;
                var canvas = document.getElementById('graph');
                canvas.setAttribute('width', width);
                canvas.setAttribute('height', height);
                var length = array.length;
                var unit = width / (length - 1.0);
                var canvasCtx = canvas.getContext('2d');
                canvasCtx.clearRect(0.0, 0.0, width, height);
                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center * (1.0 - array[(length - 1)|0]));
                for (var index = (length - 2)|0; index >=0; index = (index - 1)|0) {
                    canvasCtx.lineTo(unit * index, center * (1.0 - array[index<<1>>1]));
                }
                canvasCtx.stroke();
                canvasCtx.strokeStyle = 'rgb(0, 0, 255)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center);
                canvasCtx.lineTo(0, center);
                canvasCtx.stroke();

                strokeDottedLine(width/2,0,0,0);
                strokeDottedLine(0,0,0,center*2);
                strokeDottedLine(0,center*2,width/2,center*2);
                strokeDottedLine(width/2,center*2,width/2, 0);

                function strokeDottedLine(p1x, p1y, p2x, p2y) {
                var d = Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
                var rad = Math.atan2(p2y - p1y, p2x - p1x);
                var space = 5;
                var dotted = Math.round(d / space / 2);

                for (var i = 0; i < dotted; i++) {
                  var p3x = Math.cos(rad) * space * (i * 2) + p1x;
                  var p3y = Math.sin(rad) * space * (i * 2) + p1y;
                  var p4x = Math.cos(rad) * space * (i * 2 + 1) + p1x;
                  var p4y = Math.sin(rad) * space * (i * 2 + 1) + p1y;

                  canvasCtx.strokeStyle = 'rgb(255, 0, 0)';
                  canvasCtx.lineWidth	= 1;
                  canvasCtx.lineJoin	= 'round';
                  canvasCtx.beginPath();
                  canvasCtx.moveTo(p3x, p3y);
                  canvasCtx.lineTo(p4x, p4y);
                  canvasCtx.stroke();
                }
              };
            }

            window.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);
        })();
    </script>
</head>

<body>
    <p id='status'></p>
    <table border="1" width="600" align="center">
        <tbody>
            <tr>
                <td>Calib Frequency[Hz]</td>
                <td><form name="form_calib" id="form_calib" action=""><input size ="1" name="calibfreq" type="text" value="1000" /></form></td>
                <td><button id='calib'></button></td>
            </tr>

            <tr>
                <td>Length of recording time[sec]</td>
                <td><form name="form_recordlength" id="form_recordlength" action="">
                    <input size ="1" name="recordlength"  type="text" value="2" /></form></td>
                <td rowspan="3"><button id='measure' style = "WIDTH: 100px; HEIGHT: 50px"></button></td>
            </tr>

            <tr>
                <td>Number of recording times</td>
                <td><form name="form_recordtimes" id="form_recordtimes" action="">
                    <input size ="1" name="recordtimes"  type="text" value="6" /></form></td>
            </tr>

            <tr>
                <td>IR start points shifting to left</td>
                <td><form name="form_plusshift" id="form_plusshift" action="">
                    <input size ="1" name="plusshift" type="text" value="500" /></form></td>
            </tr>
        </tbody>
    </table>
    <div id='reverb'>
        <p>
            <button id='downloadir'>Download IR</button>
            <button id='playir'>Play IR</button>
            <button id="playconv">Convoluted Sound</button>
            <select id='select'>
                <option value='sound/clap.wav'>Clap</option>
                <option value='sound/guitar.wav'>Guitar</option>
            </select>
        </p>
        <form name="form_conv" id="form_conv" action="">
            <span>ReverbLevel :</span>
            <input type="range" id="revlevel" min="0" max="100" value="50" />
            <span id="revdisp">50</span>
        </form>
    </div>
    <p><canvas id='graph'></canvas></p>
</body>
</html>
