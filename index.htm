<!DOCTYPE HTML>
<html>

<head>
    <meta charset='utf-8'></meta>
    <title>Measure Impulse Response</title>
    <link type='text/css' rel='stylesheet' href='style.css'></link>
    <script type="text/javascript" src="fft.js"></script>
    <script type='text/javascript'>
        (function(){
            function onDOMContentLoaded() {
                var status = document.getElementById('status');
                var button = document.getElementById('button');
                var timer = null;
                status.innerHTML = 'Initialized';
                button.innerHTML = 'Measure';
                button.value = false;
                button.addEventListener('click', function(event) {
                    var value = this.value == 'false';
                    if (value) {
                        onStart();
                    } else {
                        onStop();
                    }
                    this.value = value;
                }, false);

                function onStart() {
                    status.innerHTML = 'Measuring...';
                    button.innerHTML = 'Stop';

                    /* write down process */
                    // timer = setTimeout(onFinish, 2000);
                    var N = 65536 ;
                    var freqr = new Array(N);
                    var freqi = new Array(N);
                    //var Log_SS= new Array(N);

                    var J = 4 ;
                    var a =J*Math.PI/(N/2)*Math.log(N/2);

                    for (var k=1 ; k<=N/2 ; k++){
                        freqr[k] = Math.sqrt(1/k)*Math.cos(a*k*Math.log(k));
                        freqi[k] = Math.sqrt(1/k)*Math.sin(a*k*Math.log(k));
                    }
                    var x = new FFTNayukis(N);
                    x.ifft(freqr,freqi);
                    var audioCtx = new AudioContext;
                    var channels = 1;
                    // AudioContextのサンプルレートで2秒間の空のステレオバッファを生成する

var myArrayBuffer = audioCtx.createBuffer(channels, N, audioCtx.sampleRate);


  // バッファにホワイトノイズを書き込む;
  // 単なる-1.0から1.0の間の乱数の値である
  for (var channel = 0; channel < channels; channel++) {
    // 実際のデータの配列を得る
    var nowBuffering = myArrayBuffer.getChannelData(channel);
    for (var i = 0; i < N; i++) {
      // Math.random()は[0; 1.0]である
      // 音声は[-1.0; 1.0]である必要がある
      nowBuffering[i] = freqr[i];
     // nowBuffering[i] = Math.random() * 2 - 1;
    }
  }

  // AudioBufferSourceNodeを得る
  // これはAudioBufferを再生するときに使うAudioNodeである
  var source = audioCtx.createBufferSource();

  // AudioBufferSourceNodeにバッファを設定する
  source.buffer = myArrayBuffer;

  // AudioBufferSourceNodeを出力先に接続すると音声が聞こえるようになる
  source.connect(audioCtx.destination);

  // 音源の再生を始める
  source.start();


                    console.log(freqr);
}
                function onStop() {
                    status.innerHTML = 'Interrupted';
                    button.innerHTML = 'Measure';

                    /* write down process */
                    if (timer) {
                        clearTimeout(timer);
                    }
                }

                function onFinish() {
                    status.innerHTML = 'Finished';
                    button.innerHTML = 'Measure';
                    button.value = false;

                    /* write down process */
                    timer = null;
                }

                function drawGraph(array) {
                    var width = window.innerWidth * 0.8;
                    var height = window.innerHeight * 0.8;
                    var center = height * 0.4;
                    var canvas = document.getElementById('graph');
                    canvas.setAttribute('width', width);
                    canvas.setAttribute('height', height);

                    var length = array.length;
                    var unit = width / (length - 1.0);

                    var canvasCtx = canvas.getContext('2d');
                    canvasCtx.clearRect(0.0, 0.0, width, height);
                    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
                    canvasCtx.lineWidth	= 2.0;
                    canvasCtx.lineJoin	= 'round';
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(width, center * (1.0 - array[(length - 1)|0]));
                    for (var index = (length - 2)|0; index >=0; index = (index - 1)|0) {
                        canvasCtx.lineTo(unit * index, center * (1.0 - array[index<<1>>1]));
                    }
                    canvasCtx.stroke();
                }

                array = new Float32Array(5);
                array[0] = -1.0;
                array[1] = 0.0;
                array[2] = 0.75;
                array[3] = 1.0;
                array[4] = -1.0;
                drawGraph(array);
            }

            window.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);
        })();
    </script>
</head>

<body>
    <button id='button'></button>
    <p id='status'></p>
    <canvas id='graph'></canvas>
</body>

</html>
