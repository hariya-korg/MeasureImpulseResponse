<!DOCTYPE HTML>
<html>

<head>
    <meta charset='utf-8'></meta>
    <title>Measure Impulse Response</title>
    <link type='text/css' rel='stylesheet' href='style.css'></link>
    <script type="text/javascript" src="fft.js"></script>
    <script type='text/javascript'>
        (function(){
            var console_obj = window.console;

            try{
                var N=65536*2;
                var n=1;
                var latency  = 4096;
                var recordData = new Float32Array(N);
                var audioCtx = new(window.AudioContext || window.webkitAudioContext)();
                function onDOMContentLoaded() {
                    var status = document.getElementById('status');
                    var button = document.getElementById('button');

                    status.innerHTML = 'Initialized';
                    button.innerHTML = 'Rec';
                    button.value = false;


                    button.addEventListener('click', function(event) {

                        var value = this.value == 'false';
                        if (value) {
                            onRec();
                        } else {
                            onStop();
                        }
                        this.value = value;
                    }, false);
                }

                function onRec() {
                    status.innerHTML = 'Measuring...';
                    button.innerHTML = 'Impulse Response';

                    var freqr = new Float32Array(N);
                    var freqi = new Float32Array(N);
                    var freqr2 = new Float32Array(N);
                    navigator.getUserMedia = ( navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia);

                    navigator.getUserMedia ({ audio:true }, function(stream) {
                        var shift = pinktsp(N, n, freqr, freqi, freqr2);
                        var source = audioCtx.createMediaStreamSource(stream);
                        var scriptNode = audioCtx.createScriptProcessor(latency);
                        var s=0;
                        var count = 0;
                        scriptNode.onaudioprocess = function(audioProcessingEvent) {
                            // The input buffer is the song we loaded earlier
                            var inputBuffer = audioProcessingEvent.inputBuffer;
                            // The output buffer contains the samples that will be modified and played
                            var outputBuffer = audioProcessingEvent.outputBuffer;
                            // Loop through the output channels (in this case there is only one)
                            for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
                                var inputData = inputBuffer.getChannelData(channel);
                                var outputData = outputBuffer.getChannelData(channel);
                                for (var sample = 0; sample < outputBuffer.length; sample++) {
                                    // make output equal to the same as the input
                                    if(s< N/latency){
                                        outputData[sample] = freqr2[sample+latency*s];
                                    }
                                    else{
                                        outputData[sample] = 0;
                                    }
                                }
                            }
                            var lag = 13300;
                            for (var i = 0; i < latency; i++){
                                if (0<= i+latency*s-lag-shift
                                    && i+latency*s-lag-shift< N-shift){
                                    recordData[i+latency*s-lag-shift] = inputData[i];
                                }
                                 else if(-shift<=i+latency*s-lag-shift
                                         && i+latency*s-lag-shift <0){
                                     recordData[i+latency*s-lag-shift+N] = inputData[i];
                                 }
                            }
                            source.connect(scriptNode);
                            if (sample == latency && s< N/latency+5){
                                s=s+1;
                            }
                            else if (sample == latency && s== N/latency+5){
                                audioCtx.close();

                                onFinish();
                            }
                        }
                        scriptNode.connect(audioCtx.destination);
                    }, function(err){ alert("miss") });


                };

                function onStop() {
                    status.innerHTML = 'Interrupted';
                    button.innerHTML = 'Rec';
                }

                function onFinish() {//逆Filter,encodeWAV,exportWAV
                    var ifreqr = new Float32Array(N);
                    var ifreqi = new Float32Array(N);
                    ifilter(recordData,ifreqr,ifreqi);
                    // audioCtx.resume()
                    var audioCtx = new(window.AudioContext || window.webkitAudioContext)();

                    var exportWAV =function(audioData){
                        var buffer = new ArrayBuffer(44 + audioData.length * 2);//encodeWAV start
                        var view = new DataView(buffer);
                        var writeString = function(view, offset, string) {
                            for (var i = 0; i < string.length; i++){
                                view.setUint8(offset + i, string.charCodeAt(i));
                            }
                        };
                        var floatTo16BitPCM = function(output, offset, input) {
                            for (var i = 0; i < input.length; i++, offset += 2){
                                var s = Math.max(-1, Math.min(1, input[i]));
                                output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                            }
                        };
                        writeString(view, 0, 'RIFF');  // RIFFヘッダ
                        view.setUint32(4, 32 + audioData.length * 2, true); // これ以降のファイルサイズ
                        writeString(view, 8, 'WAVE'); // WAVEヘッダ
                        writeString(view, 12, 'fmt '); // fmtチャンク
                        view.setUint32(16, 16, true); // fmtチャンクのバイト数
                        view.setUint16(20, 1, true); // フォーマットID
                        view.setUint16(22, 1, true); // チャンネル数
                        view.setUint32(24, audioCtx.sampleRate, true); // サンプリングレート
                        view.setUint32(28, audioCtx.sampleRate * 2, true); // データ速度
                        view.setUint16(32, 2, true); // ブロックサイズ
                        view.setUint16(34, 16, true); // サンプルあたりのビット数
                        writeString(view, 36, 'data'); // dataチャンク
                        view.setUint32(40, audioData.length * 2, true); // 波形データのバイト数
                        floatTo16BitPCM(view, 44, audioData); // 波形データ    //encodeWAV end

                        var audioBlob = new Blob([view], { type: 'audio/wav' });
                        var myURL = window.URL || window.webkitURL;
                        var url = myURL.createObjectURL(audioBlob);

                        return url;
                    };
                    var a = document.querySelectorAll('.download')[0];//downloadWAV
                    var wavurl = exportWAV(ifreqr);
                    a.download = 'ir.wav';
                    a.href = wavurl;
                    a.classList.remove('disabled');
                    drawGraph(ifreqr);

                    status.innerHTML = 'Finished';
                    button.innerHTML = 'Measure';
                    button.value = false;
                }

                function pinktsp(N, n, freqr, freqi, freqr2){
                    var J = Math.round(N/4*n)*2 ;
                    var a =J*Math.PI/(N/2)/Math.log(N/2);

                    for (var k=1 ; k<=N/2 ; k++){
                        freqr[k] = Math.sqrt(1/k)*Math.cos(-a*k*Math.log(k));
                        freqi[k] = Math.sqrt(1/k)*Math.sin(-a*k*Math.log(k));
                    }
                    for (var k=N/2+1 ; k<N ; k++){
                        freqr[k] = freqr[N-k];
                        freqi[k] = -freqi[N-k];
                    }
                    freqr[0] = 1.0;
                    freqi[0] = 0;

                    var fftn = new FFTNayukis(N);
                    fftn.ifft(freqr,freqi);

                    var shift =Math.round(N/2-J/2*(1+(1/Math.log(N/2))));
                    var D=1;
                    for (var q=1 ; q<10000 ; q++){
                        if (D === 0) { break; }

                        for (var n=0 ; n<shift ; n++){
                            freqr2[n]=freqr[n-shift+N];
                        }
                        for (var m=shift ; m<N ; m++){
                            freqr2[m]=freqr[m-shift];
                        }

                        var sample = 50;
                        var D=sample-1;
                        for (var l=1 ; l<sample ; l++){
                             if(freqr2[N-sample+l]<freqr2[N-sample+l-1])
                             D = sample-l-1;
                        }
                        shift=shift+D;
                    }
                    normalize(freqr2);
                    // drawGraph(freqr2);
                    return shift;
                }

                function ifilter(freqr,ifreqr,ifreqi){
                    var freqi = new Float32Array(N);
                    var fftn = new FFTNayukis(N);
                    fftn.fft(freqr,freqi);
                    var J = Math.round(N/4*n)*2 ;
                    var a =J*Math.PI/(N/2)/Math.log(N/2);
                    for (var k=0; k<=N/2; k++) {
                     ifreqr[k] = Math.sqrt(k)*(freqr[k]*Math.cos(a*k*Math.log(k))-freqi[k]*Math.sin(a*k*Math.log(k)));
                     ifreqi[k] = Math.sqrt(k)*(freqr[k]*Math.sin(a*k*Math.log(k))+freqi[k]*Math.cos(a*k*Math.log(k)));
                    }
                    for (var k=N/2+1 ; k<N ; k++){
                        ifreqr[k] = ifreqr[N-k];
                        ifreqi[k] = -ifreqi[N-k];
                    }
                     ifreqr[0]=1.0;
                     ifreqi[0]=0;

                    fftn.ifft(ifreqr,ifreqi);
                    normalize(ifreqr);
                    //console.log(ifreqr);
                    //return ifreqr;
                }

                function normalize(array){
                    var max = Math.max.apply(null,array);
                    var min = Math.abs(Math.min.apply(null,array));
                    if (max<min)
                        max = min ;
                    for (var l=0 ; l<array.length ; l++){
                        array[l]=array[l]/max;
                    }
                }

                function drawGraph(array) {
                    var width = window.innerWidth * 0.8;
                    var height = window.innerHeight * 0.8;
                    var center = height * 0.4;
                    var canvas = document.getElementById('graph');
                    canvas.setAttribute('width', width);
                    canvas.setAttribute('height', height);

                    var length = array.length;
                    var unit = width / (length - 1.0);

                    var canvasCtx = canvas.getContext('2d');
                    canvasCtx.clearRect(0.0, 0.0, width, height);
                    canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
                    canvasCtx.lineWidth	= 1;
                    canvasCtx.lineJoin	= 'round';
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(width, center * (1.0 - array[(length - 1)|0]));
                    for (var index = (length - 2)|0; index >=0; index = (index - 1)|0) {
                        canvasCtx.lineTo(unit * index, center * (1.0 - array[index<<1>>1]));
                    }
                    canvasCtx.stroke();

                    canvasCtx.strokeStyle = 'rgb(0, 0, 255)';
                    canvasCtx.lineWidth	= 1;
                    canvasCtx.lineJoin	= 'round';
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(width, center);
                    canvasCtx.lineTo(0, center);

                    canvasCtx.stroke();
                }
            }catch(e){
                console.log(e);
            }
        window.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);
        })();
    </script>
</head>

<body>
    <button id='button'></button>
    <p id='status'></p>
    <p><a href="#" class="download disabled">Download IR WAV file</a></p>
    <canvas id='graph'></canvas>
</body>

</html>
