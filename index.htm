<!DOCTYPE HTML>
<html>

<head>
    <meta charset='utf-8'></meta>
    <title>Measure Impulse Response</title>
    <link type='text/css' rel='stylesheet' href='style.css'></link>
    <script type="text/javascript" src="fft.js"></script>
    <script src="jquery-2.0.3.min.js"></script>
    <script src="jquery.xdomainajax.js"></script>
    <script type='text/javascript'>


        (function(){//wavのステレオ化、グラフの色指定、ダウンロードボタンの無効化、
            var status,measure,calib;
            var console_obj = window.console;
            var N,n,j,a;
            var latency  = 4096;
            var sampleRate;
            var ir;
            var scriptNode;
            var audioCtx = new(window.AudioContext || window.webkitAudioContext)();

            var ir2;
            var files;
            var source2 = null;
            var convolver = audioCtx.createConvolver();
            var revlevel = audioCtx.createGain();
            revlevel.gain.value=0.5;
            convolver.connect(revlevel);
            revlevel.connect(audioCtx.destination);
            var buffers = [];
            var loadidx = 0;
            var req = new XMLHttpRequest();

            function LoadBuffers() {
                req.open("GET", files[loadidx], true);
                req.responseType = "arraybuffer";
                req.onload = function() {
                    if(req.response) {
                        audioCtx.decodeAudioData(req.response,function(b){
                            buffers[loadidx]=b;
                            if(++loadidx < files.length)
                                LoadBuffers();
                        },function(){});
                    }
                    else
                        buffers[loadidx] = audioCtx.createBuffer(VBArray(req.responseBody).toArray(), false);
                };
                req.send();
            }

            function Setup() {
                var lev=document.getElementById("revlevel").value;
                revlevel.gain.value=parseInt(lev)*0.01;
                document.getElementById("revdisp").innerHTML=lev;
            }

            function Play() {
                if(source2 == null) {
                    source2 = audioCtx.createBufferSource();
                    source2.buffer = buffers[0];
                    convolver.buffer = buffers[1];
                    source2.loop = true;
                    // source2.connect(audioCtx.destination);
                    source2.connect(convolver);
                    source2.start(0);
                }
                else {
                    source2.stop(0);
                    source2 = null;
                }
            }
            function onDOMContentLoaded() {

                status = document.getElementById('status');
                measure = document.getElementById('measure');
                calib = document.getElementById('calib');

                status.innerHTML = 'Initialized';
                measure.innerHTML = 'Start';
                measure.value = false;
                measure.addEventListener('click', function(event) {
                    var value = this.value == 'false';
                    if (value) {
                        onStartMeasure();
                    } else {
                        onStopMeasure();
                    }
                    this.value = value;
                }, false);

                calib.innerHTML = 'Calib';
                calib.value = false;
                calib.addEventListener('click', function(event) {
                    var value2 = this.value == 'false';
                    if (value2) {
                        onStartCalib();
                    } else {
                        onStopCalib();
                    }
                    this.value = value2;
                }, false);

                document.getElementById('load').addEventListener('click',function(event){
                    files = [
                        form_conv.samplefile.value,"ir3.wav"
                    ];
                    LoadBuffers();
                },false);


                document.getElementById('playir').addEventListener('click',function(event){
                    soundplay(ir);
                },false);

                document.getElementById('samplefile').addEventListener('change',function(event){
                    files = [
                        form_conv.samplefile.value,"ir3.wav"
                    ];
                },false);

                document.getElementById('playconv').addEventListener('click',function(event){
                    Play();
                },false);

                document.getElementById('revlevel').addEventListener('change',function(event){
                    Setup();
                },false);

                document.getElementById("irlink").style.display="none";
            }

            var oscillator;
            function onStartCalib(){
                calib.innerHTML =  'StopSine'
                oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.value =eval(form_calib.calibfreq.value);
                oscillator.connect(audioCtx.destination);
                oscillator.start();
                navigator.getUserMedia = ( navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia ||
                navigator.msGetUserMedia);
                navigator.getUserMedia ({audio: {
                    "mandatory": {
                        "googEchoCancellation": false,
                        "googAutoGainControl": false,
                        "googNoiseSuppression": false,
                        "googHighpassFilter": false
                    },
                    "optional": []
                }}, function(stream) {
                    var source = audioCtx.createMediaStreamSource(stream);
                    var inputmax=0;
                    var inputmin=0;
                    scriptNode = audioCtx.createScriptProcessor(latency);
                    scriptNode.onaudioprocess = function(audioProcessingEvent) {
                        // The input buffer is the song we loaded earlier
                        var inputBuffer = audioProcessingEvent.inputBuffer;
                        for (var channel = 0; channel < inputBuffer.numberOfChannels; channel++) {
                            var inputData = inputBuffer.getChannelData(channel);
                            var inputmax = Math.max.apply(null,inputData);
                            var inputmin = Math.abs(Math.min.apply(null,inputData));
                            if (inputmax<inputmin){
                                    inputmax = inputmin ;
                            }
                        }
                        var maxdb = 20*Math.log10(inputmax);
                        if(maxdb > -6){
                            status.innerHTML='too large '+ Math.floor(maxdb) +'dB';
                            status.style.color = "red";
                        }else if(maxdb < -20){
                            status.innerHTML='too small '+ Math.floor(maxdb) +'dB';
                            status.style.color = "black";
                        }
                        else{
                            status.innerHTML = 'proper '+ Math.floor(maxdb) +'dB';
                            status.style.color = "green";
                        }
                    }
                    source.connect(scriptNode);
                    scriptNode.connect(audioCtx.destination);
                },function(err){ alert("miss") });
            }

            function onStopCalib(){
                status.innerHTML = 'Initialized';
                status.style.color = "black";
                calib.innerHTML =  'Calib'
                oscillator.stop();
                scriptNode.disconnect();
            }

            function onStartMeasure() {
                status.innerHTML = 'Measuring...';
                measure.innerHTML = 'Stop';
                document.getElementById("irlink").style.display="none";

                N= Math.round(65536*4/3*eval(form_recordlength.recordlength.value));
                console.log(N);
                for (var b=1; b<20; b++){
                    if (Math.pow(2,b)<N && N<=Math.pow(2,b+1)){
                        N = Math.pow(2,b+1);
                    }
                }
                console.log(N);
                n=1;//0~1
                J = Math.round(N/4*n)*2;//実効長
                a = J*Math.PI/(N/2)/Math.log(N/2);//計算式
                try{
                    var recordData = new Float32Array(N);
                    var repeat = eval(form_recordtimes.recordtimes.value);//同期加算回数
                    sampleRate = audioCtx.sampleRate;
                    navigator.getUserMedia = ( navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.msGetUserMedia);

                    navigator.getUserMedia ({audio: {
                        "mandatory": {
                            "googEchoCancellation": false,
                            "googAutoGainControl": false,
                            "googNoiseSuppression": false,
                            "googHighpassFilter": false
                        },
                        "optional": []
                    }}, function(stream) {
                        var pinktsp = createPinktsp(N);
                        var shift = pinktsp.shift;
                        var source = audioCtx.createMediaStreamSource(stream);
                        scriptNode = audioCtx.createScriptProcessor(latency);
                        var s=0;
                        var l=0;
                        //  pinktsp[0]=1;
                        //  shift=0;
                        scriptNode.onaudioprocess = function(audioProcessingEvent) {
                            var inputBuffer = audioProcessingEvent.inputBuffer;
                            var outputBuffer = audioProcessingEvent.outputBuffer;
                            // Loop through the output channels (in this case there is only one)
                            for (var channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
                                var inputData = inputBuffer.getChannelData(channel);
                                var outputData = outputBuffer.getChannelData(channel);
                                for (var sample = 0; sample < outputBuffer.length; sample++) {
                                    // make output equal to the same as the input
                                    if(s< N/latency){
                                        outputData[sample] = pinktsp[sample+latency*s];
                                    }else{
                                        outputData[sample] = 0;
                                    }
                                }
                            }
                            var lag = 13300+eval(form_plusshift.plusshift.value);
                            for (var i = 0; i < latency; i++){
                                for (m=1; m<repeat;m++){
                                    if (N*m<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*(m+1)-shift){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift;
                                            recordData[p] += inputData[i];
                                    } else if(N*m-shift<= i+latency*(s+l*N/latency)-lag-shift
                                    && i+latency*(s+l*N/latency)-lag-shift< N*m){
                                        var p =i+latency*(s+l*N/latency)-lag-N*m-shift+N;
                                        recordData[p] += inputData[i];
                                    }
                                }
                            }
                            if (sample == latency && s< N/latency-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency-1 && l<repeat-1){
                                s=0;
                                l=l+1;
                                drawGraph(recordData);

                            }else if (sample == latency && s< N/latency+5 && l==repeat-1){
                                s=s+1;
                            }else if (sample == latency && s== N/latency+5 && l==repeat-1){
                                this.disconnect();
                                normalize(recordData);
                                drawGraph(recordData);
                                ir = onFinishMeasure(recordData);
                            }
                        }
                        source.connect(scriptNode);
                        scriptNode.connect(audioCtx.destination);
                    }, function(err){ alert("miss") });
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function onStopMeasure() {
                status.innerHTML = 'Interrupted';
                measure.innerHTML = 'Start';
                scriptNode.disconnect();
            }

            function onFinishMeasure(recordData) {//逆Filter,encodeWAV,exportWAV
                var ir = getImpulseResponse(recordData);
                ir2 = new Float32Array(N/2);
                for (m=0; m< ir.length/2; m++){
                    ir2[m] = ir[m];
                }
                var d = document.querySelectorAll('.download')[0];//downloadWAV
                var wavurl = exportWAV(ir2);
                d.download = 'ir.wav';
                d.href = wavurl;
                d.classList.remove('disabled');
                status.innerHTML = 'Finished';
                measure.innerHTML = 'Start';
                measure.value = false;
                drawGraph(ir);
                document.getElementById("irlink").style.display="block";
                return ir2;
            }

            function exportWAV(audioData){
                try{
                    var stereo = new Float32Array(audioData.length*2);
                    for (s=0; s<audioData.length;s++){
                        stereo[2*s] = audioData[s];
                        stereo[2*s+1] = audioData[s];
                    }
                    var buffer = new ArrayBuffer(44 + stereo.length * 2);//encodeWAV start
                    var view = new DataView(buffer);
                    var writeString = function(view, offset, string) {
                        for (var i = 0; i < string.length; i++){
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };
                    var floatTo16BitPCM = function(output, offset, input) {
                        for (var i = 0; i < input.length; i++, offset += 2){
                            var s = Math.max(-1, Math.min(1, input[i]));
                            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                        }
                    };
                    writeString(view, 0, 'RIFF');  // RIFFヘッダ
                    view.setUint32(4, 32 + stereo.length * 2, true); // これ以降のファイルサイズ
                    writeString(view, 8, 'WAVE'); // WAVEヘッダ
                    writeString(view, 12, 'fmt '); // fmtチャンク
                    view.setUint32(16, 16, true); // fmtチャンクのバイト数
                    view.setUint16(20, 1, true); // フォーマットID
                    view.setUint16(22, 2, true); // チャンネル数
                    view.setUint32(24, sampleRate, true); // サンプリングレート
                    view.setUint32(28, sampleRate * 2*2, true); // データ速度
                    view.setUint16(32, 2*2, true); // ブロックサイズ
                    view.setUint16(34, 16, true); // サンプルあたりのビット数
                    writeString(view, 36, 'data'); // dataチャンク
                    view.setUint32(40, stereo.length * 2, true); // 波形データのバイト数
                    floatTo16BitPCM(view, 44, stereo); // 波形データ    //encodeWAV end

                    var audioBlob = new Blob([view], { type: 'audio/wav' });
                    var myURL = window.URL || window.webkitURL;
                    var url = myURL.createObjectURL(audioBlob);

                    return url;
                }catch(e){
                    status.innerHTML = 'Error : ' + e.message;
                }
            };

            function createPinktsp(N){
                var freqr = new Float32Array(N);
                var freqi = new Float32Array(N);

                for (var k=1 ; k<=N/2 ; k++){
                    freqr[k] = Math.sqrt(1/k)*Math.cos(-a*k*Math.log(k));
                    freqi[k] = Math.sqrt(1/k)*Math.sin(-a*k*Math.log(k));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    freqr[k] = freqr[N-k];
                    freqi[k] = -freqi[N-k];
                }
                freqr[0] = 1.0;
                freqi[0] = 0;

                var fftn = new FFTNayukis(N);
                fftn.ifft(freqr,freqi);

                var shift =Math.round(N/2-J/2*(1+(1/Math.log(N/2))));
                var D=1;
                for (var q=1 ; q<10000 ; q++){
                    if (D === 0) { break; }

                    for (var n=0 ; n<shift ; n++){
                        freqi[n]=freqr[n-shift+N];//freqiにfreqrをシフトしたものを入れる
                    }
                    for (var m=shift ; m<N ; m++){
                        freqi[m]=freqr[m-shift];
                    }

                    var sample = 50;
                    var D=sample-1;
                    for (var l=1 ; l<sample ; l++){
                         if(freqi[N-sample+l]<freqi[N-sample+l-1])
                         D = sample-l-1;
                    }
                    shift=shift+D;
                }
                normalize(freqi);
                freqi.shift = shift;
                return freqi;
            }

            function getImpulseResponse(recordData){
                var freqi = new Float32Array(N);
                var ifreqr = new Float32Array(N);
                var ifreqi = new Float32Array(N);
                var fftn = new FFTNayukis(N);
                fftn.fft(recordData,freqi);
                for (var k=0; k<=N/2; k++) {
                 ifreqr[k] = Math.sqrt(k)*(recordData[k]*Math.cos(a*k*Math.log(k))-freqi[k]*Math.sin(a*k*Math.log(k)));
                 ifreqi[k] = Math.sqrt(k)*(recordData[k]*Math.sin(a*k*Math.log(k))+freqi[k]*Math.cos(a*k*Math.log(k)));
                }
                for (var k=N/2+1 ; k<N ; k++){
                    ifreqr[k] = ifreqr[N-k];
                    ifreqi[k] = -ifreqi[N-k];
                }
                 ifreqr[0]=1.0;
                 ifreqi[0]=0;
                fftn.ifft(ifreqr,ifreqi);
                normalize(ifreqr);
                return ifreqr;
            }

            function normalize(array){
                var copy = array.slice(0);
                copy.sort();
                var max = copy[copy.length-1];
                var min = Math.abs(copy[0]);
                 if (max<min)
                    max = min ;
                for (var l=0 ; l<array.length ; l++){
                    array[l]=array[l]/max;
                }
            }

            function drawGraph(array) {
                var width = window.innerWidth * 0.8;
                var height = window.innerHeight * 0.8;
                var center = height * 0.4;
                var canvas = document.getElementById('graph');
                canvas.setAttribute('width', width);
                canvas.setAttribute('height', height);
                var length = array.length;
                var unit = width / (length - 1.0);
                var canvasCtx = canvas.getContext('2d');
                canvasCtx.clearRect(0.0, 0.0, width, height);
                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center * (1.0 - array[(length - 1)|0]));
                for (var index = (length - 2)|0; index >=0; index = (index - 1)|0) {
                    canvasCtx.lineTo(unit * index, center * (1.0 - array[index<<1>>1]));
                }
                canvasCtx.stroke();
                canvasCtx.strokeStyle = 'rgb(0, 0, 255)';
                canvasCtx.lineWidth	= 1;
                canvasCtx.lineJoin	= 'round';
                canvasCtx.beginPath();
                canvasCtx.moveTo(width, center);
                canvasCtx.lineTo(0, center);
                canvasCtx.stroke();

                strokeDottedLine(width/2,0,0,0);
                strokeDottedLine(0,0,0,center*2);
                strokeDottedLine(0,center*2,width/2,center*2);
                strokeDottedLine(width/2,center*2,width/2, 0);

                function strokeDottedLine(p1x, p1y, p2x, p2y) {
                var d = Math.sqrt(Math.pow(p2x - p1x, 2) + Math.pow(p2y - p1y, 2));
                var rad = Math.atan2(p2y - p1y, p2x - p1x);
                var space = 5;
                var dotted = Math.round(d / space / 2);

                for (var i = 0; i < dotted; i++) {
                  var p3x = Math.cos(rad) * space * (i * 2) + p1x;
                  var p3y = Math.sin(rad) * space * (i * 2) + p1y;
                  var p4x = Math.cos(rad) * space * (i * 2 + 1) + p1x;
                  var p4y = Math.sin(rad) * space * (i * 2 + 1) + p1y;

                  canvasCtx.strokeStyle = 'rgb(255, 0, 0)';
                  canvasCtx.lineWidth	= 1;
                  canvasCtx.lineJoin	= 'round';
                  canvasCtx.beginPath();
                  canvasCtx.moveTo(p3x, p3y);
                  canvasCtx.lineTo(p4x, p4y);
                  canvasCtx.stroke();
                }
              };
            }

            function soundplay(array){
                var channels = 1;
                var myArrayBuffer = audioCtx.createBuffer(channels, N, audioCtx.sampleRate);
                for (var channel = 0; channel < channels; channel++) {
                    // 実際のデータの配列を得る
                    var nowBuffering = myArrayBuffer.getChannelData(channel);
                    for (var i = 0; i < N; i++) {
                        // Math.random()は[0; 1.0]である
                        // 音声は[-1.0; 1.0]である必要がある
                        nowBuffering[i] = array[i];
                        // nowBuffering[i] = Math.random() * 2 - 1;
                    }
                }                // AudioBufferSourceNodeを得る
                // これはAudioBufferを再生するときに使うAudioNodeである
                var source = audioCtx.createBufferSource();
                // AudioBufferSourceNodeにバッファを設定する
                source.buffer = myArrayBuffer;
                // AudioBufferSourceNodeを出力先に接続すると音声が聞こえるようになる
                source.connect(audioCtx.destination);
                // 音源の再生を始める
                source.start();
            };

            window.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);
        })();
    </script>
</head>

<body>
    <p id='status'></p>
    <table border="1" width="600" align="center" >
    <tbody>
    <tr>
        <td>Calib Frequency(Hz)</td>
        <td><form name="form_calib" id="form_calib" action=""><input size ="1" name="calibfreq" type="text" value="1000" /></form></td>
        <td><button id='calib'></button></td>
    </tr>

    <tr>
        <td>Length of recording time(sec)</td>
        <td><form name="form_recordlength" id="form_recordlength" action="">
            <input size ="1" name="recordlength"  type="text" value="2" /></form></td>
        <td rowspan="3"><button id='measure' style = "WIDTH: 100px; HEIGHT: 50px"></button></td>
    </tr>

    <tr>
        <td>Number of recording times</td>
        <td><form name="form_recordtimes" id="form_recordtimes" action="">
            <input size ="1" name="recordtimes"  type="text" value="6" /></form></td>
    </tr>

    <tr>
        <td>IR start points shifting to left</td>
        <td><form name="form_plusshift" id="form_plusshift" action="">
            <input size ="1" name="plusshift" type="text" value="500" /></form></td>
    </tr>
    </tbody>
    </table>
    <!-- <input id="file_select" type="file" multiple="multiple" /> -->
<button id='playir'>Play IR</button>   <button id="playconv">Convoluted Sound</button><button id="load">load file</button>
<p><a href="#" class="download disabled" id="irlink">Download IR WAV file</a></p>
<form name="form_conv" id="form_conv" action="">
    <p>sample file: <input size ="1" id ="samplefile" name="samplefile" type="text" value="guitar.wav" /></p>
    ReverbLevel : <input type="range" id="revlevel" min="0" max="100" value="50" /><span id="revdisp">50</span>
</form>

<canvas id='graph'></canvas>

</body>
</html>
